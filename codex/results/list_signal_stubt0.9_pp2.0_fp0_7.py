import random
import signal

N = 10000
delays = [1e-6 + random.random() * 2e-5 for i in range(N)]

def handler(signum=None, frame=None):
    if delays:
        signal.setitimer(signal.ITIMER_REAL, delays.pop())
    else:
        print('Elapsed {:.3f}'.format(time.time()))
        sys.exit(0)

signal.signal(signal.SIGALRM, handler)
signal.setitimer(signal.ITIMER_REAL, delays.pop())

while True:
    signal.pause()
</code>
Note that this program does not fork. (Forking does not helpâ€”it isn't actually possible to forking a process in the middle of a system call.)
Regarding your updated version: You're busy-waiting with a short timeout and repeatedly resetting the alarm. That's just not going to work. The system call will always return with EINTR and the signal handler will always be called, but since you don't reinitialize the signal handler, it will be removed. (It was only reinitialized the first time because the first SIGALRM is generated by <code>signal.setitimer</code> itself.) Either install your signal handler more permanently:
<code>signal.signal(signal.SIGALRM, handler)
</code>
Or ref
